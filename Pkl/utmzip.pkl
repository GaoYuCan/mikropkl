open module utmzip
import "Randomish.pkl"
import "UTM.pkl"
import "URL.pkl"
import "SVG.pkl"

name : String

backend : UTM.BackendType

architecture : UTM.SystemArchitecture

memory : DataSize = UTM.defaultMemSize

cpus : UTM.CPUCount = UTM.defaultCPUCount

imageDownloadUrl : URL.Download

additionalDisks : List<DataSize>

notes : String = UTM.defaultNotes

logoSvg : SVG.Icon = new SVG.Pkl {} 

configPlist : UTM.Config = new {

  Backend = backend
  
  System {
    Architecture = architecture
    MemorySize = memory.toUnit("mib").value
    CPUCount = cpus
  }
  
  Information {
    Name = name
    Notes = notes
    Icon = logoSvg.name
  }
  
  Drive {
    new {
      Backend = backend
      Architecture = architecture
      ImageName = imageDownloadUrl.filename
    }
    for (_index in additionalDisks.mapIndexed((i,e)->Pair(i,e))) {
      new {
        Identifier = Randomish.hashUUID(_index.first)
        Backend = backend
        Architecture = architecture
        ImageName = "qdisk\(_index.first).qcow2"
      }
    }
  }
  
  Network {
    new {
      MacAddress = Randomish.macAddress(name, 0, if (backend == "Apple") "a" else "e")
      Backend = backend
      // example to control QEMU network card: 
      // Hardware = if (backend == "QEMU" && architecture == "x86_64") "e1000" else null
    } 
  }
  
  Serial {
    new UTM.PttyTerminal {
      when (backend == "QEMU") { Target = "Auto" }
    }
  }
}

// NOTE: `output` below uses "multiple file output" so a `-m <outdir>` is needed in "pkl eval"

output {

  files {

    // required: config.plist
    ["\(name).utm/config.plist"] {
        value = configPlist
        renderer = new PListRenderer {}
    }
    
    // store Pkl PCF format in package 
    ["\(name).utm/config.pkl"] {
        value = configPlist
        renderer = new PcfRenderer {}
    }
    
    // logo
    ["\(name).utm/Data/\(logoSvg.name)"] {
        text = logoSvg.text
    }
    
    // required: a ".url" file with VM disk image download URL
    ["\(name).utm/Data/\(imageDownloadUrl.name).url"] {
        text = imageDownloadUrl.url
    }
    
    when (additionalDisks.length > 0) {
      for ( _pair in additionalDisks.mapIndexed((i,e) -> Pair(i,e))) {
        ["\(name).utm/Data/qdisk\(_pair.first).size"] { 
          text = _pair.second.toUnit("mb").value.toString() 
        }
      }
    }
    
    when (backend == "Apple") {
      ["\(name).utm/Data/efi_vars.fd.localcp"] { 
        text = "efi_vars.fd" 
      }
    }

  } // files

} // output
